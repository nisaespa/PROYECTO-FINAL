# 游댠 INDUSPLAYTHON - PROYECTO FINAL 游댠
*Nicolas Estupi침an* - *Santiago Avenda침o*
## 游놓 Logo IndusPlaython 游놓
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/LOGO%20indusplaython.jpg" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>

## Nuestro proyecto final trata de un sal칩n o men칰 de 3 juegos, los cuales son: Ahorcado, Piedra, papel o tijera y Sopa de letras. 
## El juego inicia mostrando el nombre del grupo "INDUSPLAYTHON", y luego aparece el men칰 con las opciones de juego, o la opci칩n de salirse.
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in1.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in2.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in3.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in4.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in5.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in6.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in7.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in8.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in9.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
10
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in10.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
11
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in11.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
12
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in12.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
13
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in13.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
14
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in14.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
15
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in15.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
16
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in16.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
17
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in17.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
18
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in18.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
19
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in19.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
20
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in20.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
21
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in21.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
22
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in22.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
23
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in23.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
24
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in24.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
25
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in25.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
26
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in26.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
27
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in27.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>
28
<div align='center'>
<figure> <img src="https://raw.githubusercontent.com/nisaespa/PROYECTO-FINAL/main/imagenes%20proyecto%20final/in28.png" alt="" width="700" height="auto"/></br>
<figcaption><b></b></figcaption></figure>
</div>

#### Estableciendo un condicional para verificar que la dimensi칩n de la sopa de letras sea un n칰mero N tal que 10<= N <= 30 se empezar치 a desarrollar el c칩digo, que empezar치 almacenando palabras ingresadas por el usuario en una lista para luego acceder a estas.

```python
# Abecedario y dimensi칩n de la matriz ingresados por el usuario
abecedario = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
N = int(input("Ingrese la dimensi칩n de la matriz (Un numero que N tal que 10<= N <= 30): "))


if 10<= N <= 30:
    palabras = []
    cuantas_palabras = int(input("쮺uantas palabras desea ingresar? (ingrese un numero entero): "))

    for i in range(cuantas_palabras): #Ingreso las palabras en una lista para luego acceder a estas 
        palabra = input("Ingrese la palabra: ")
        palabras.append(palabra)
```

#### Para hacer m치s espec칤fico cada paso, utilic칠 funciones para cada cosa que necesitaba que hiciera el programa, partiendo por generar la funci칩n que simula un puntero que decidir치 aleatoriamente la posici칩n donde ser치 puesta cada palabra ingresada por el usuario, asimismo este puntero decide la direcci칩n en la que estar치 la palabra, definiendo los avances en x ^ y como una pareja de escalares o un vector en R2.

```python
# Funci칩n pa generar el cursor aleatorio con posici칩n y direcci칩n
    def generar_cursor(dimension):# Se genera el cursor que es como un puntero que decide aleatoriamente donde va a ser la posicion inicial y luego la direcci칩n 

        fila = random.randint(0, dimension - 1)
        columna = random.randint(0, dimension - 1)
        avanX = random.choice([-1, 0, 1])
        avanY = random.choice([-1, 0, 1])


        if avanX == 0 and avanY == 0:
            avanX = 1
        return fila, columna, avanX, avanY
```

#### La funci칩n posterior a esta, es una verificaci칩n sobre el espacio suficiente para cada palabra, si bien no se usa len() para medir la longitud de la palabra, se verificar치 letra por letra si esta cabe en el siguiente, actualizando cada coordenada en x ^ y por cada letra, utilizando valores booleanos decidir치 si es posible poner la palabra o no, decidiendo esto letra por letra. (Cabe la posibilidad de que se omitan palabras).


```python
# Funci칩n pa verificar si una palabra cabe en la matriz desde una posici칩n y direcci칩n dadas
    def palabra_cabe(ajiaco, palabra, cursor):
        x, y, avanX, avanY = cursor #Indican la posicion inicial y la direccion en la que se intentar치 colocar 

        for letra in palabra:
            # Verificar si la posici칩n est치 dentro de la matriz
            if not (0 <= x < len(ajiaco) and 0 <= y < len(ajiaco[0])):
                return False
            x += avanX #En cada uno se va a actualizar la posicion x ^ y segun la direccion dada por avanX ^ avanY
            y += avanY

        return True  
```

  
#### La funci칩n posterior (colocar_palabra) tiene un funcionamiento similar a la anterior, ya que eval칰a si es posible colocar cada letra y en dado caso la posici칩n de la matriz: ajiaco, ser치 la letra en cuesti칩n.

```python
# Funci칩n pa colocar una palabra en la matriz a partir de una posici칩n y direcci칩n dadas
    def colocar_palabra(ajiaco, palabra, cursor): #Cursor ser치 algo cmo un puntero que selecciona aleatoriamente cual ser치 la posicion inicial de la palabra

        x, y, avanX, avanY = cursor
        for letra in palabra:
            # Verificanding si la posici칩n est치 dentro de la matriz
            if 0 <= x < len(ajiaco) and 0 <= y < len(ajiaco[0]): #Si x ^ y tan en el rango del tama침o de la fila y columna 
                ajiaco[x][y] = letra

                x += avanX #Le suma cada x que avance
                y += avanY #Le suma cada y que avance

            #Ahora, 쯟a palabra cabe
                

            else:
                    break
        return ajiaco
```
  
#### Para generar la matriz: ajiaco, se usar치n listas que luego se llenar치n de espacio de vacios,  y posterior a esto se llamar치n las funciones anteriores para poner en la matriz las palabras y dejar espacios vac칤os donde no haya palabras.  En la funci칩n: generar_matriz, se pretende hacer esto de una manera agradable , por lo que se imprimir치n los 칤ndices de fila y de columna, asegurando tambi칠n que por cada fila haya una columna . Posterior a esto se llenar치 cada espacio vac칤o restante con letras aleatorias.

```python
# Funci칩n para generar la matriz final con palabras colocadas aleatoriamente
    def generar_matriz_palabras(palabras, dimension):
        ajiaco = [[' '] * dimension for _ in range(dimension)] #Se llenar치 de espacios vac칤os la sopa para luego acceder a esos espacios llenando con palabras y despu칠s con letras

        for palabra in palabras:
            # Intentar colocar la palabra hasta encontrar un espacio v치lido
            while True:  #Utilizo una bandera para hacer mientras 
                cursor = generar_cursor(dimension)
                if palabra_cabe(ajiaco, palabra, cursor): # E intenta hasta que se pueda poner la palabra 
                    ajiaco = colocar_palabra(ajiaco, palabra, cursor)
                    break

        return ajiaco #Retorna la matriz o sopa 
# Funci칩n pa imprimir la matriz m치s pintosa 
    def imprimir_matriz(ajiaco):                                                                   
        regla = f"   {('0 1 2 3 4 5 6 7 8 9 ' * int(len(ajiaco) / 10 + 1))[:len(ajiaco) * 2]}\n" #Regla es la variable que determinar치 el numero de las colummnas , la cantidad de repeticiones se determina dividiendo todo sobre 10 + 1 para asegurar que hayan siempre numeros suficientes sobre las columanas
        linea = regla                                                                            #Tomando la parte que es el doble de la longitud de la matriz para cubrir bien las columnas
        for i, fila in enumerate(ajiaco):  #Uso enumarate para a침adir la columna de numeros y sea m치s aspera la matriz de la sopa, obteniendo el indice de la fila y la fila 
            linea += f"{i:2d} {' '.join(fila)}\n" # Se pretende imprimir el numero de fila con al menos dos digitos para mantener la alineacion y se une las letras de la fila con un espacio entre ellas  
        print(linea + regla)


    def rellenar_sopa (ajiaco):  #Por cada espacio que encuentre vacio en la matriz que ya tiene ingresada las palabras, ponga una letra aleatoria
        for x in range(len(ajiaco)):
            for y in range(len(ajiaco)):
                if ajiaco[x][y] ==" ":
                    ajiaco[x][y] = np.random.choice(abecedario)
```

#### Para mostrar todo lo anterior en la consola, se acceder치n a las funciones establecidas previamente.

```python
# Generar la matriz final y mostrarla
matriz_resultante = generar_matriz_palabras(palabras, N)
rellenar_sopa(matriz_resultante)
imprimir_matriz(matriz_resultante)
```
#### Con fin de terminar el c칩digo, se establecen las funciones para encontrar las  palabras y la l칩gica que estas tendr치n, donde se evaluar치 las coordenadas iniciales y finales de cada palabra, y en cada caso se usar치 un m칠todo de extracci칩n de estas de la matriz ya que el c칩digo present칩 constantes problemas mientras se usaba el mismo m칠todo de extracci칩n para los tres casos.

```python
# Hacer que el usuario encuentre palabras hasta que todas sean encontradas
    palabras_restantes = set(palabras.copy())  #Utilizo set para volver la lista palabras en un arreglo similar a las listas pero mucho m치s practica la eliminacion de palabras restantes


    # Funci칩n para encontrar palabras en la sopa
    def encontrar_palabra(ajiaco, inicio, fin):
        print(f"Inicio: {inicio}, Fin: {fin}")

        if inicio[0] == fin[0]: #Aqui, si la palabra est치 en la misma fila, utilizo slicing pa extraer la palabra  
            palabra_encontrada = ''.join(ajiaco[inicio[0]][min(inicio[1], fin[1]):max(inicio[1], fin[1]) + 1])
        elif inicio[1] == fin[1]: #Si las coordenadas pertencen a la misma columna, utilizo una comprensi칩n de lista para obtener las letras de la palabra correspondiente en las filas min y max  
            palabra_encontrada = ''.join(ajiaco[i][inicio[1]] for i in range(min(inicio[0], fin[0]), max(inicio[0], fin[0]) + 1))
        else: #De no ser como lo anterior, es una coordenada diagonal donde utilizo la finci칩n zip para extraer las letras de la sopa desde la posicion inicio y fin y luego las concatena para formar la palabra   
            palabra_encontrada = ''.join(ajiaco[i][j] for i, j in zip(range(inicio[0], fin[0] + 1), range(inicio[1], fin[1] + 1)))

        print(f"Palabra encontrada: {palabra_encontrada}") #Con fines de depuracion 
        return palabra_encontrada
```

#### Finalizando el c칩digo, se utiliza un ciclo while para iterar mientras hayan palabras en la lista: [palabras_restantes], donde ser치n solicitadas al usuario, las coordenadas iniciales y finales de la palabra, convirtiendo estas a enteros y evaluando si estas coordenadas si corresponden a una palabra. En este punto el c칩digo presenta un problema que no encontramos c칩mo solucionar y es que al evaluar las coordenadas, en caso de que correspondan a una palabra, imprime: Encontraste la palabra, sin embargo tambi칠n imprime: No es una palabra v치lida, int칠ntelo de nuevo, como si las coordenadas no coincidieran con una palabra en la matriz, por lo que fu칠 editada la funci칩n: encontrar_palabras hasta que esto se solucion칩, sin embargo fue una soluci칩n parcial, ya que funcion칩 en los primeros dos intentos de usar el c칩digo y se volvi칩 al mismo problema

```python
while palabras_restantes:
        # Obtener coordenadas del usuario
        inicio = input("Ingrese la coordenada inicial (fila columna)(separando por un espacio la fila de la columna  춰Siga la especificaci칩n por favor!): ").split() #Por cada palabra ingresada por el usuario, la descomopne en letras usando split
        fin = input("Ingrese la coordenada final (fila columna)(separando por un espacio la fila de la columna  춰Siga la especificaci칩n por favor!): ").split()

        # Convertir las coordenadas a n칰meros enteros
        inicio = tuple(map(int, inicio))   #Convierte las cordenadas porporcionadas a numeros enteros y luego vuelve a almacenarlos en la variable inicio y fin 
        fin = tuple(map(int, fin))  #Utilizo la funcion map(int) para realizar comparaciones numericas y acceder elementos en la matriz

        # Verificar si las coordenadas son v치lidas
        if not (0 <= inicio[0] < N and 0 <= inicio[1] < N and 0 <= fin[0] < N and 0 <= fin[1] < N): #Se verifica sdi est치n dentro de la dimension de la sopa
            print("Coordenadas inv치lidas. Int칠ntelo de nuevo.")
            continue

        # Verificar si las coordenadas forman una l칤nea recta #Esta es la manera en la que accedo a la palabra para eliminarla de la mtriz
        if inicio[0] == fin[0] or inicio[1] == fin[1]:
            # Extraer la palabra de la matriz
            palabra_encontrada = encontrar_palabra(matriz_resultante, inicio, fin)

            if palabra_encontrada in palabras_restantes:
                palabras_restantes.remove(palabra_encontrada)
                print(f"춰Encontraste la palabra '{palabra_encontrada}'!")
                print(f"Palabras restantes: {', '.join(palabras_restantes)}")
            else:
                print("No es una palabra v치lida. Int칠ntelo de nuevo.")
        else:
            print("Las coordenadas deben formar una l칤nea recta. Int칠ntelo de nuevo.")

    # Mensaje de felicitaciones al encontrar todas las palabras
    print("춰Felicidades! 춰Has encontrado todas las palabras!")
else:
    print("Fue advertido de que el numero deb칤a estar entre 10 y 30, ahora vuelva a correr el programa")
```
